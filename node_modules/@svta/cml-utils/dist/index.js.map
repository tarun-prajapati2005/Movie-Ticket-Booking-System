{"version":3,"file":"index.js","names":["base64decode: typeof decodeBase64","base64encode: typeof encodeBase64","view: DataView<ArrayBuffer>","char!: number","uuid","error","uuid"],"sources":["../src/arrayBufferToHex.ts","../src/arrayBufferToUuid.ts","../src/decodeBase64.ts","../src/base64decode.ts","../src/encodeBase64.ts","../src/base64encode.ts","../src/convertUint8ToUint16.ts","../src/UTF_16.ts","../src/UTF_16_BE.ts","../src/UTF_16_LE.ts","../src/UTF_8.ts","../src/decodeText.ts","../src/Encoding.ts","../src/getBandwidthBps.ts","../src/hexToArrayBuffer.ts","../src/RequestType.ts","../src/roundToEven.ts","../src/stringToUint16.ts","../src/unescapeHtml.ts","../src/urlToRelativePath.ts","../src/uuid.ts","../src/uuidToArrayBuffer.ts"],"sourcesContent":["/**\n * Encodes an ArrayBuffer as a hexadecimal string.\n *\n * @param buffer - The ArrayBuffer to encode.\n * @returns The hexadecimal string representation.\n *\n *\n * @beta\n *\n * @example\n * {@includeCode ../test/arrayBufferToHex.test.ts#example}\n */\nexport function arrayBufferToHex(buffer: ArrayBuffer): string {\n\tconst view = new Uint8Array(buffer)\n\treturn view.reduce((result, byte) => result + byte.toString(16).padStart(2, '0'), '')\n}\n","import { arrayBufferToHex } from './arrayBufferToHex.ts'\n\n/**\n * Converts an ArrayBuffer to a UUID string.\n *\n * @param buffer - The ArrayBuffer to convert.\n * @returns The UUID string representation.\n *\n *\n * @beta\n *\n * @example\n * {@includeCode ../test/arrayBufferToUuid.test.ts#example}\n */\nexport function arrayBufferToUuid(buffer: ArrayBuffer): string {\n\tconst hex = arrayBufferToHex(buffer)\n\treturn hex.replace(/(.{8})(.{4})(.{4})(.{4})(.{12})/, '$1-$2-$3-$4-$5')\n}\n","/**\n * Decodes a base64 encoded string into binary data\n *\n * @param str - The base64 encoded string to decode\n * @returns The decoded binary data\n *\n *\n * @beta\n */\nexport function decodeBase64(str: string): Uint8Array {\n\treturn new Uint8Array([...atob(str)].map((a) => a.charCodeAt(0)))\n}\n","import { decodeBase64 } from './decodeBase64.ts'\n\n/**\n * Decodes a base64 encoded string into binary data\n *\n * @param str - The base64 encoded string to decode\n * @returns The decoded binary data\n *\n *\n * @beta\n *\n * @deprecated Use {@link decodeBase64} instead.\n *\n * @see {@link decodeBase64}\n */\nexport const base64decode: typeof decodeBase64 = decodeBase64\n","/**\n * Encodes binary data to base64\n *\n * @param binary - The binary data to encode\n * @returns The base64 encoded string\n *\n *\n * @beta\n */\nexport function encodeBase64(binary: Uint8Array): string {\n\treturn btoa(String.fromCharCode(...binary))\n}\n","import { encodeBase64 } from './encodeBase64.ts'\n\n/**\n * Encodes binary data to base64\n *\n * @param binary - The binary data to encode\n * @returns The base64 encoded string\n *\n *\n * @beta\n *\n * @deprecated Use {@link encodeBase64} instead.\n *\n * @see {@link encodeBase64}\n */\nexport const base64encode: typeof encodeBase64 = encodeBase64\n","/**\n * Converts a Uint8Array to a Uint16Array by aligning its buffer.\n *\n * @param input - The Uint8Array to convert\n * @returns A properly aligned Uint16Array\n *\n * @beta\n */\nexport function convertUint8ToUint16(input: Uint8Array): Uint16Array {\n\tif (input.length % 2 !== 0) {\n\t\tconst padded = new Uint8Array(input.length + 1)\n\t\tpadded.set(input)\n\t\treturn new Uint16Array(padded.buffer)\n\t}\n\treturn new Uint16Array(input.buffer)\n}\n","/**\n * UTF-16 Encoding.\n *\n *\n * @beta\n */\nexport const UTF_16 = 'utf-16'\n","/**\n * UTF-16 Big Endian Encoding.\n *\n *\n * @beta\n */\nexport const UTF_16_BE = 'utf-16be'\n","/**\n * UTF-16 Little Endian Encoding.\n *\n *\n * @beta\n */\nexport const UTF_16_LE = 'utf-16le'\n","/**\n * UTF-8 Encoding.\n *\n *\n * @beta\n */\nexport const UTF_8 = 'utf-8'\n","import type { DecodeTextOptions } from './DecodeTextOptions.ts'\nimport { UTF_16 } from './UTF_16.ts'\nimport { UTF_16_BE } from './UTF_16_BE.ts'\nimport { UTF_16_LE } from './UTF_16_LE.ts'\nimport { UTF_8 } from './UTF_8.ts'\n\n/**\n * Converts an ArrayBuffer or ArrayBufferView to a string. Similar to `TextDecoder.decode`\n * but with a fallback for environments that don't support `TextDecoder`.\n *\n * @param data - The data to decode.\n * @param options - The options for the decoding.\n * @returns The string representation of the ArrayBuffer.\n *\n *\n * @beta\n *\n * @example\n * {@includeCode ../test/decodeText.test.ts#example}\n */\nexport function decodeText(data: ArrayBuffer | ArrayBufferView<ArrayBuffer>, options: DecodeTextOptions = {}): string {\n\tlet view: DataView<ArrayBuffer>\n\n\tif (data instanceof ArrayBuffer) {\n\t\tview = new DataView(data)\n\t}\n\telse {\n\t\tview = new DataView(data.buffer, data.byteOffset, data.byteLength)\n\t}\n\n\tlet byteOffset = 0\n\tlet { encoding } = options\n\n\t// If no encoding is provided, try to detect it from the BOM\n\tif (!encoding) {\n\t\tconst first = view.getUint8(0)\n\t\tconst second = view.getUint8(1)\n\n\t\t// UTF-8 BOM\n\t\tif (first == 0xef && second == 0xbb && view.getUint8(2) == 0xbf) {\n\t\t\tencoding = UTF_8\n\t\t\tbyteOffset = 3\n\t\t}\n\t\t// UTF-16 BE BOM\n\t\telse if (first == 0xfe && second == 0xff) {\n\t\t\tencoding = UTF_16_BE\n\t\t\tbyteOffset = 2\n\t\t}\n\t\t// UTF-16 LE BOM\n\t\telse if (first == 0xff && second == 0xfe) {\n\t\t\tencoding = UTF_16_LE\n\t\t\tbyteOffset = 2\n\t\t}\n\t\telse {\n\t\t\tencoding = UTF_8\n\t\t}\n\t}\n\n\tif (typeof TextDecoder !== 'undefined') {\n\t\treturn new TextDecoder(encoding).decode(view)\n\t}\n\n\tconst { byteLength } = view\n\tconst endian = encoding !== UTF_16_BE\n\tlet str = ''\n\tlet char!: number\n\n\twhile (byteOffset < byteLength) {\n\t\tswitch (encoding) {\n\t\t\tcase UTF_8:\n\t\t\t\tchar = view.getUint8(byteOffset)\n\n\t\t\t\t// Single byte (ASCII)\n\t\t\t\tif (char < 128) {\n\t\t\t\t\tbyteOffset++\n\t\t\t\t}\n\t\t\t\t// 2-byte sequence\n\t\t\t\telse if (char >= 194 && char <= 223) {\n\t\t\t\t\tif (byteOffset + 1 < byteLength) {\n\t\t\t\t\t\tconst byte2 = view.getUint8(byteOffset + 1)\n\t\t\t\t\t\tif (byte2 >= 128 && byte2 <= 191) {\n\t\t\t\t\t\t\tchar = ((char & 0x1F) << 6) | (byte2 & 0x3F)\n\t\t\t\t\t\t\tbyteOffset += 2\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t// Invalid sequence, skip\n\t\t\t\t\t\t\tbyteOffset++\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// Incomplete sequence, skip\n\t\t\t\t\t\tbyteOffset++\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// 3-byte sequence\n\t\t\t\telse if (char >= 224 && char <= 239) {\n\t\t\t\t\tif (byteOffset + 2 <= byteLength - 1) {\n\t\t\t\t\t\tconst byte2 = view.getUint8(byteOffset + 1)\n\t\t\t\t\t\tconst byte3 = view.getUint8(byteOffset + 2)\n\t\t\t\t\t\tif (byte2 >= 128 && byte2 <= 191 && byte3 >= 128 && byte3 <= 191) {\n\t\t\t\t\t\t\tchar = ((char & 0x0F) << 12) | ((byte2 & 0x3F) << 6) | (byte3 & 0x3F)\n\t\t\t\t\t\t\tbyteOffset += 3\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t// Invalid sequence, skip\n\t\t\t\t\t\t\tbyteOffset++\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// Incomplete sequence, skip\n\t\t\t\t\t\tbyteOffset++\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// 4-byte sequence\n\t\t\t\telse if (char >= 240 && char <= 244) {\n\t\t\t\t\tif (byteOffset + 3 <= byteLength - 1) {\n\t\t\t\t\t\tconst byte2 = view.getUint8(byteOffset + 1)\n\t\t\t\t\t\tconst byte3 = view.getUint8(byteOffset + 2)\n\t\t\t\t\t\tconst byte4 = view.getUint8(byteOffset + 3)\n\t\t\t\t\t\tif (byte2 >= 128 && byte2 <= 191 && byte3 >= 128 && byte3 <= 191 && byte4 >= 128 && byte4 <= 191) {\n\t\t\t\t\t\t\tchar = ((char & 0x07) << 18) | ((byte2 & 0x3F) << 12) | ((byte3 & 0x3F) << 6) | (byte4 & 0x3F)\n\t\t\t\t\t\t\tbyteOffset += 4\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t// Invalid sequence, skip\n\t\t\t\t\t\t\tbyteOffset++\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// Incomplete sequence, skip\n\t\t\t\t\t\tbyteOffset++\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Invalid byte, skip\n\t\t\t\telse {\n\t\t\t\t\tbyteOffset++\n\t\t\t\t}\n\t\t\t\tbreak\n\n\t\t\tcase UTF_16_BE:\n\t\t\tcase UTF_16:\n\t\t\tcase UTF_16_LE:\n\t\t\t\tchar = view.getUint16(byteOffset, endian)\n\t\t\t\tbyteOffset += 2\n\t\t\t\tbreak\n\t\t}\n\n\t\tstr += String.fromCodePoint(char)\n\t}\n\n\treturn str\n}\n","import { UTF_16 } from './UTF_16.ts'\nimport { UTF_16_BE } from './UTF_16_BE.ts'\nimport { UTF_16_LE } from './UTF_16_LE.ts'\nimport { UTF_8 } from './UTF_8.ts'\nimport type { ValueOf } from './ValueOf.ts'\n\n/**\n * Text encoding types.\n *\n *\n * @beta\n */\nexport const Encoding = {\n\tUTF8: UTF_8 as typeof UTF_8,\n\tUTF16: UTF_16 as typeof UTF_16,\n\tUTF16BE: UTF_16_BE as typeof UTF_16_BE,\n\tUTF16LE: UTF_16_LE as typeof UTF_16_LE,\n} as const\n\n/**\n * Text encoding types.\n *\n *\n * @beta\n */\nexport type Encoding = ValueOf<typeof Encoding>;\n","import type { ResourceTiming } from './ResourceTiming.ts'\n\n/**\n * Converts a ResourceTiming sample to bandwidth in bits per second (bps).\n *\n * @param sample - A ResourceTiming sample\n * @returns\n *\n *\n * @beta\n */\nexport function getBandwidthBps(sample: ResourceTiming): number {\n\tconst durationSeconds = sample.duration / 1000\n\tconst bandwidthBps = sample.encodedBodySize * 8 / durationSeconds\n\treturn bandwidthBps\n}\n","/**\n * Decodes a hexadecimal string into an ArrayBuffer.\n *\n * @param hex - The hexadecimal string to decode.\n * @returns The decoded ArrayBuffer.\n *\n *\n * @beta\n *\n * @example\n * {@includeCode ../test/hexToArrayBuffer.test.ts#example}\n */\nexport function hexToArrayBuffer(hex: string): ArrayBuffer {\n\tconst buffer = new ArrayBuffer(hex.length / 2)\n\tconst view = new Uint8Array(buffer)\n\tfor (let i = 0; i < hex.length; i += 2) {\n\t\tview[i / 2] = parseInt(hex.slice(i, i + 2), 16)\n\t}\n\treturn buffer\n}\n","import type { ValueOf } from './ValueOf.ts'\n\n/**\n * The content type of the request.\n *\n *\n * @enum\n *\n * @beta\n */\nexport const RequestType = {\n\tTEXT: 'text' as const,\n\tJSON: 'json' as const,\n\tBLOB: 'blob' as const,\n\tARRAY_BUFFER: 'arrayBuffer' as const,\n\tDOCUMENT: 'document' as const,\n} as const\n\n/**\n * @beta\n */\nexport type RequestType = ValueOf<typeof RequestType>;\n","/**\n * This implements the rounding procedure described in step 2 of the \"Serializing a Decimal\" specification.\n * This rounding style is known as \"even rounding\", \"banker's rounding\", or \"commercial rounding\".\n *\n * @param value - The value to round\n * @param precision - The number of decimal places to round to\n * @returns The rounded value\n *\n *\n * @beta\n */\nexport function roundToEven(value: number, precision: number): number {\n\tif (value < 0) {\n\t\treturn -roundToEven(-value, precision)\n\t}\n\n\tconst decimalShift = Math.pow(10, precision)\n\tconst isEquidistant = Math.abs(((value * decimalShift) % 1) - 0.5) < Number.EPSILON\n\n\tif (isEquidistant) {\n\t\t// If the tail of the decimal place is 'equidistant' we round to the nearest even value\n\t\tconst flooredValue = Math.floor(value * decimalShift)\n\t\treturn (flooredValue % 2 === 0 ? flooredValue : flooredValue + 1) / decimalShift\n\t}\n\telse {\n\t\t// Otherwise, proceed as normal\n\t\treturn Math.round(value * decimalShift) / decimalShift\n\t}\n}\n","/**\n * Converts a string to a Uint16Array.\n *\n * @param str - The string to convert\n * @returns A Uint16Array representation of the string\n *\n *\n * @beta\n *\n * @example\n * {@includeCode ../test/stringToUint16.test.ts#example}\n */\nexport function stringToUint16(str: string): Uint16Array<ArrayBuffer> {\n\tconst buffer = new ArrayBuffer(str.length * 2)\n\tconst view = new DataView(buffer)\n\n\tfor (let i = 0; i < str.length; i++) {\n\t\tview.setUint16(i * 2, str.charCodeAt(i), true) // true for little-endian\n\t}\n\n\treturn new Uint16Array(buffer)\n}\n","const escapedHtml = /&(?:amp|lt|gt|quot|apos|nbsp|lrm|rlm|#[xX]?[0-9a-fA-F]+);/g\n\n/**\n * Unescapes HTML entities\n *\n * @param text - The text to unescape\n * @returns The unescaped text\n *\n *\n * @beta\n *\n * @example\n * {@includeCode ../test/unescapeHtml.test.ts#example}\n */\nexport function unescapeHtml(text: string): string {\n\tif (text.indexOf('&') === -1) {\n\t\treturn text\n\t}\n\n\treturn text.replace(escapedHtml, (match) => {\n\t\tswitch (match) {\n\t\t\tcase '&amp;': return '&'\n\t\t\tcase '&lt;': return '<'\n\t\t\tcase '&gt;': return '>'\n\t\t\tcase '&quot;': return '\"'\n\t\t\tcase '&apos;': return '\\''\n\t\t\tcase '&nbsp;': return '\\u{a0}'\n\t\t\tcase '&lrm;': return '\\u{200e}'\n\t\t\tcase '&rlm;': return '\\u{200f}'\n\t\t\tdefault: {\n\t\t\t\tif (match[1] === '#') {\n\t\t\t\t\tconst code = match[2] === 'x' || match[2] === 'X' ? parseInt(match.slice(3), 16) : parseInt(match.slice(2), 10)\n\t\t\t\t\treturn String.fromCodePoint(code)\n\t\t\t\t}\n\t\t\t\treturn match\n\t\t\t}\n\t\t}\n\t})\n}\n","/**\n * Constructs a relative path from a URL.\n *\n * @param url - The destination URL\n * @param base - The base URL\n * @returns The relative path\n *\n *\n * @beta\n */\nexport function urlToRelativePath(url: string, base: string): string {\n\tconst to = new URL(url)\n\tconst from = new URL(base)\n\n\tif (to.origin !== from.origin) {\n\t\treturn url\n\t}\n\n\tconst toPath = to.pathname.split('/').slice(1)\n\tconst fromPath = from.pathname.split('/').slice(1, -1)\n\n\t// remove common parents\n\tconst length = Math.min(toPath.length, fromPath.length)\n\n\tfor (let i = 0; i < length; i++) {\n\t\tif (toPath[i] !== fromPath[i]) {\n\t\t\tbreak\n\t\t}\n\n\t\ttoPath.shift()\n\t\tfromPath.shift()\n\t}\n\n\t// add back paths\n\twhile (fromPath.length) {\n\t\tfromPath.shift()\n\t\ttoPath.unshift('..')\n\t}\n\n\tconst relativePath = toPath.join('/')\n\n\t// preserve query parameters and hash of the destination url\n\treturn relativePath + to.search + to.hash\n}\n","/**\n * Generate a random v4 UUID\n *\n * @returns A random v4 UUID\n *\n *\n * @beta\n */\nexport function uuid(): string {\n\ttry {\n\t\treturn crypto.randomUUID()\n\t}\n\tcatch (error) {\n\t\ttry {\n\t\t\tconst url = URL.createObjectURL(new Blob())\n\t\t\tconst uuid = url.toString()\n\t\t\tURL.revokeObjectURL(url)\n\t\t\treturn uuid.slice(uuid.lastIndexOf('/') + 1)\n\t\t}\n\t\tcatch (error) {\n\t\t\tlet dt = new Date().getTime()\n\t\t\tconst uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\n\t\t\t\tconst r = (dt + Math.random() * 16) % 16 | 0\n\t\t\t\tdt = Math.floor(dt / 16)\n\t\t\t\treturn (c == 'x' ? r : (r & 0x3 | 0x8)).toString(16)\n\t\t\t})\n\t\t\treturn uuid\n\t\t}\n\t}\n}\n","import { hexToArrayBuffer } from './hexToArrayBuffer.ts'\n\n/**\n * Converts a UUID string to an ArrayBuffer.\n *\n * @param uuid - The UUID string to convert.\n * @returns The ArrayBuffer representation.\n *\n *\n * @beta\n *\n * @example\n * {@includeCode ../test/uuidToArrayBuffer.test.ts#example}\n */\nexport function uuidToArrayBuffer(uuid: string): ArrayBuffer {\n\tconst hex = uuid.replace(/-/g, '')\n\treturn hexToArrayBuffer(hex)\n}\n"],"mappings":"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"}