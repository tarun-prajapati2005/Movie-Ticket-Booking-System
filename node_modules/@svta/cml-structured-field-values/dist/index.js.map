{"version":3,"file":"index.js","names":["DECIMAL: string","INTEGER: string","INTEGER_DECIMAL: string","STRING_REGEX: RegExp","parameters: SfParameters | undefined","innerList: SfItem[]","value: SfDictionary","member: SfItem | SfInnerList","value: SfMember[]"],"sources":["../src/SfItem.ts","../src/utils/DICT.ts","../src/parse/ParsedValue.ts","../src/utils/throwError.ts","../src/parse/parseError.ts","../src/utils/INNER.ts","../src/utils/BARE_ITEM.ts","../src/utils/BOOLEAN.ts","../src/parse/parseBoolean.ts","../src/utils/BYTES.ts","../src/parse/parseByteSequence.ts","../src/utils/DATE.ts","../src/utils/DECIMAL.ts","../src/utils/INTEGER.ts","../src/utils/INTEGER_DECIMAL.ts","../src/utils/isInvalidInt.ts","../src/parse/parseIntegerOrDecimal.ts","../src/parse/parseDate.ts","../src/utils/STRING.ts","../src/utils/STRING_REGEX.ts","../src/parse/parseString.ts","../src/SfToken.ts","../src/utils/TOKEN.ts","../src/parse/parseToken.ts","../src/parse/parseBareItem.ts","../src/utils/KEY.ts","../src/parse/parseKey.ts","../src/parse/parseParameters.ts","../src/parse/parseItem.ts","../src/parse/parseInnerList.ts","../src/parse/parseItemOrInnerList.ts","../src/parse/parseDict.ts","../src/decodeSfDict.ts","../src/utils/ITEM.ts","../src/decodeSfItem.ts","../src/utils/LIST.ts","../src/parse/parseList.ts","../src/decodeSfList.ts","../src/serialize/serializeError.ts","../src/serialize/serializeBoolean.ts","../src/serialize/serializeByteSequence.ts","../src/serialize/serializeInteger.ts","../src/serialize/serializeDate.ts","../src/serialize/serializeDecimal.ts","../src/serialize/serializeString.ts","../src/utils/symbolToStr.ts","../src/serialize/serializeToken.ts","../src/serialize/serializeBareItem.ts","../src/serialize/serializeKey.ts","../src/serialize/serializeParams.ts","../src/serialize/serializeItem.ts","../src/serialize/serializeInnerList.ts","../src/serialize/serializeDict.ts","../src/encodeSfDict.ts","../src/encodeSfItem.ts","../src/serialize/serializeList.ts","../src/encodeSfList.ts"],"sourcesContent":["import type { SfBareItem } from './SfBareItem.ts'\nimport type { SfParameters } from './SfParameters.ts'\n\n/**\n * Structured Field Item\n *\n *\n * @beta\n */\nexport class SfItem {\n\n\tvalue: SfBareItem\n\n\tparams?: SfParameters\n\n\tconstructor(value: any, params?: SfParameters) {\n\t\tif (Array.isArray(value)) {\n\t\t\tvalue = value.map((v) => (v instanceof SfItem) ? v : new SfItem(v))\n\t\t}\n\n\t\tthis.value = value\n\t\tthis.params = params\n\t}\n}\n","export const DICT = 'Dict'\n","/**\n * @internal\n */\nexport type ParsedValue<T> = {\n\tvalue: T;\n\tsrc: string;\n};\n\n/**\n * @internal\n */\nexport function parsedValue<T>(value: T, src: string): ParsedValue<T> {\n\treturn { value, src }\n}\n","function format(value: any) {\n\tif (Array.isArray(value)) {\n\t\treturn JSON.stringify(value)\n\t}\n\tif (value instanceof Map) {\n\t\treturn 'Map{}'\n\t}\n\tif (value instanceof Set) {\n\t\treturn 'Set{}'\n\t}\n\tif (typeof value === 'object') {\n\t\treturn JSON.stringify(value)\n\t}\n\treturn String(value)\n}\n\nexport function throwError(action: string, src: any, type: string, cause?: any): Error {\n\treturn new Error(`failed to ${action} \"${format(src)}\" as ${type}`, { cause })\n}\n","import { throwError } from '../utils/throwError.ts'\n\n/**\n * @internal\n */\nexport function parseError(src: any, type: string, cause?: any): Error {\n\treturn throwError('parse', src, type, cause)\n}\n","export const INNER = 'Inner List'\n","export const BARE_ITEM = 'Bare Item'\n","export const BOOLEAN = 'Boolean'\n","import { BOOLEAN } from '../utils/BOOLEAN.ts'\nimport type { ParsedValue } from './ParsedValue.ts'\nimport { parsedValue } from './ParsedValue.ts'\nimport { parseError } from './parseError.ts'\n\n// 4.2.8.  Parsing a Boolean\n//\n// Given an ASCII string as input_string, return a Boolean. input_string\n// is modified to remove the parsed value.\n//\n// 1.  If the first character of input_string is not \"?\", fail parsing.\n//\n// 2.  Discard the first character of input_string.\n//\n// 3.  If the first character of input_string matches \"1\", discard the\n//     first character, and return true.\n//\n// 4.  If the first character of input_string matches \"0\", discard the\n//     first character, and return false.\n//\n// 5.  No value has matched; fail parsing.\n/**\n * @internal\n */\nexport function parseBoolean(src: string): ParsedValue<boolean> {\n\tlet i = 0\n\tif (src[i] !== '?') {\n\t\tthrow parseError(src, BOOLEAN)\n\t}\n\n\ti++\n\n\tif (src[i] === '1') {\n\t\treturn parsedValue(true, src.substring(++i))\n\t}\n\n\tif (src[i] === '0') {\n\t\treturn parsedValue(false, src.substring(++i))\n\t}\n\n\tthrow parseError(src, BOOLEAN)\n}\n","export const BYTES = 'Byte Sequence'\n","import { decodeBase64 } from '@svta/cml-utils'\nimport { BYTES } from '../utils/BYTES.ts'\nimport type { ParsedValue } from './ParsedValue.ts'\nimport { parsedValue } from './ParsedValue.ts'\nimport { parseError } from './parseError.ts'\n\n// 4.2.7.  Parsing a Byte Sequence\n//\n// Given an ASCII string as input_string, return a Byte Sequence.\n// input_string is modified to remove the parsed value.\n//\n// 1.  If the first character of input_string is not \":\", fail parsing.\n//\n// 2.  Discard the first character of input_string.\n//\n// 3.  If there is not a \":\" character before the end of input_string,\n//     fail parsing.\n//\n// 4.  Let b64_content be the result of consuming content of\n//     input_string up to but not including the first instance of the\n//     character \":\".\n//\n// 5.  Consume the \":\" character at the beginning of input_string.\n//\n// 6.  If b64_content contains a character not included in ALPHA, DIGIT,\n//     \"+\", \"/\" and \"=\", fail parsing.\n//\n// 7.  Let binary_content be the result of Base 64 Decoding [RFC4648]\n//     b64_content, synthesizing padding if necessary (note the\n//     requirements about recipient behavior below).\n//\n// 8.  Return binary_content.\n//\n// Because some implementations of base64 do not allow rejection of\n// encoded data that is not properly \"=\" padded (see [RFC4648],\n// Section 3.2), parsers SHOULD NOT fail when \"=\" padding is not\n// present, unless they cannot be configured to do so.\n//\n// Because some implementations of base64 do not allow rejection of\n// encoded data that has non-zero pad bits (see [RFC4648], Section 3.5),\n// parsers SHOULD NOT fail when non-zero pad bits are present, unless\n// they cannot be configured to do so.\n//\n// This specification does not relax the requirements in [RFC4648],\n// Section 3.1 and 3.3; therefore, parsers MUST fail on characters\n// outside the base64 alphabet, and on line feeds in encoded data.\n/**\n * @internal\n */\nexport function parseByteSequence(src: string): ParsedValue<Uint8Array> {\n\tif (src[0] !== ':') {\n\t\tthrow parseError(src, BYTES)\n\t}\n\n\tsrc = src.substring(1)\n\tif (src.includes(':') === false) {\n\t\tthrow parseError(src, BYTES)\n\t}\n\n\tconst re = /(^.*?)(:)/g\n\tconst b64_content = (re.exec(src) as any)[1]\n\tsrc = src.substring(re.lastIndex)\n\n\t// pass b64_content char check step 6\n\treturn parsedValue(\n\t\tdecodeBase64(b64_content),\n\t\tsrc,\n\t)\n}\n","export const DATE = 'Date'\n","export const DECIMAL: string = 'Decimal'\n","export const INTEGER: string = 'Integer'\n","import { DECIMAL } from './DECIMAL.ts'\nimport { INTEGER } from './INTEGER.ts'\n\nexport const INTEGER_DECIMAL: string = `${INTEGER} or ${DECIMAL}`\n","export function isInvalidInt(value: number): boolean {\n\treturn value < -999999999999999 || 999999999999999 < value\n}\n","import { INTEGER_DECIMAL } from '../utils/INTEGER_DECIMAL.ts'\nimport { isInvalidInt } from '../utils/isInvalidInt.ts'\nimport type { ParsedValue } from './ParsedValue.ts'\nimport { parsedValue } from './ParsedValue.ts'\nimport { parseError } from './parseError.ts'\n\n// 4.2.4.  Parsing an Integer or Decimal\n//\n// Given an ASCII string as input_string, return an Integer or Decimal.\n// input_string is modified to remove the parsed value.\n//\n// NOTE: This algorithm parses both Integers (Section 3.3.1) and\n// Decimals (Section 3.3.2), and returns the corresponding structure.\n//\n// 1.   Let type be \"integer\".\n//\n// 2.   Let sign be 1.\n//\n// 3.   Let input_number be an empty string.\n//\n// 4.   If the first character of input_string is \"-\", consume it and\n//      set sign to -1.\n//\n// 5.   If input_string is empty, there is an empty integer; fail\n//      parsing.\n//\n// 6.   If the first character of input_string is not a DIGIT, fail\n//      parsing.\n//\n// 7.   While input_string is not empty:\n//\n//      1.  Let char be the result of consuming the first character of\n//          input_string.\n//\n//      2.  If char is a DIGIT, append it to input_number.\n//\n//      3.  Else, if type is \"integer\" and char is \".\":\n//\n//          1.  If input_number contains more than 12 characters, fail\n//              parsing.\n//\n//          2.  Otherwise, append char to input_number and set type to\n//              \"decimal\".\n//\n//      4.  Otherwise, prepend char to input_string, and exit the loop.\n//\n//      5.  If type is \"integer\" and input_number contains more than 15\n//          characters, fail parsing.\n//\n//      6.  If type is \"decimal\" and input_number contains more than 16\n//          characters, fail parsing.\n//\n// 8.   If type is \"integer\":\n//\n//      1.  Parse input_number as an integer and let output_number be\n//          the product of the result and sign.\n//\n//      2.  If output_number is outside the range -999,999,999,999,999\n//          to 999,999,999,999,999 inclusive, fail parsing.\n//\n// 9.   Otherwise:\n//\n//      1.  If the final character of input_number is \".\", fail parsing.\n//\n//      2.  If the number of characters after \".\" in input_number is\n//          greater than three, fail parsing.\n//\n//      3.  Parse input_number as a decimal number and let output_number\n//          be the product of the result and sign.\n//\n// 10.  Return output_number.\n/**\n * @internal\n */\nexport function parseIntegerOrDecimal(src: string): ParsedValue<number> {\n\tconst orig = src\n\tlet sign = 1\n\tlet num = ''\n\tlet value\n\tconst i = 0\n\tconst error = parseError(orig, INTEGER_DECIMAL)\n\n\tif (src[i] === '-') {\n\t\tsign = -1\n\t\tsrc = src.substring(1)\n\t}\n\n\tif (src.length <= 0) {\n\t\tthrow error\n\t}\n\n\tconst re_integer = /^(\\d+)?/g\n\tconst result_integer = re_integer.exec(src) as any\n\tif (result_integer[0].length === 0) {\n\t\tthrow error\n\t}\n\tnum += result_integer[1]\n\tsrc = src.substring(re_integer.lastIndex)\n\n\tif (src[0] === '.') {\n\t\t// decimal\n\t\tif (num.length > 12) {\n\t\t\tthrow error\n\t\t}\n\n\t\tconst re_decimal = /^(\\.\\d+)?/g\n\t\tconst result_decimal = re_decimal.exec(src) as any\n\t\tsrc = src.substring(re_decimal.lastIndex)\n\t\t// 9.2.  If the number of characters after \".\" in input_number is greater than three, fail parsing.\n\t\tif (result_decimal[0].length === 0 || result_decimal[1].length > 4) {\n\t\t\tthrow error\n\t\t}\n\n\t\tnum += result_decimal[1]\n\t\t// 7.6.  If type is \"decimal\" and input_number contains more than 16 characters, fail parsing.\n\t\tif (num.length > 16) {\n\t\t\tthrow error\n\t\t}\n\n\t\tvalue = parseFloat(num) * sign\n\t}\n\telse {\n\t\t// integer\n\t\t// 7.5.  If type is \"integer\" and input_number contains more than 15 characters, fail parsing.\n\t\tif (num.length > 15) {\n\t\t\tthrow error\n\t\t}\n\n\t\tvalue = parseInt(num) * sign\n\t\tif (isInvalidInt(value)) {\n\t\t\tthrow parseError(num, INTEGER_DECIMAL)\n\t\t}\n\t}\n\n\treturn parsedValue(value, src)\n}\n","import { DATE } from '../utils/DATE.ts'\nimport type { ParsedValue } from './ParsedValue.ts'\nimport { parsedValue } from './ParsedValue.ts'\nimport { parseError } from './parseError.ts'\nimport { parseIntegerOrDecimal } from './parseIntegerOrDecimal.ts'\n\n// 4.2.9.  Parsing a Date\n//\n// Given an ASCII string as input_string, return a Date. input_string is\n// modified to remove the parsed value.\n//\n// 1.  If the first character of input_string is not \"@\", fail parsing.\n//\n// 2.  Discard the first character of input_string.\n//\n// 3.  Let output_date be the result of running Parsing an Integer or\n//     Decimal (Section 4.2.4) with input_string.\n//\n// 4.  If output_date is a Decimal, fail parsing.\n//\n// 5.  Return output_date.\n/**\n * @internal\n */\nexport function parseDate(src: string): ParsedValue<Date> {\n\tlet i = 0\n\tif (src[i] !== '@') {\n\t\tthrow parseError(src, DATE)\n\t}\n\n\ti++\n\tconst date = parseIntegerOrDecimal(src.substring(i))\n\n\tif (Number.isInteger(date.value) === false) {\n\t\tthrow parseError(src, DATE)\n\t}\n\n\treturn parsedValue(\n\t\tnew Date(date.value * 1000),\n\t\tdate.src,\n\t)\n}\n","export const STRING = 'String'\n","// eslint-disable-next-line no-control-regex\nexport const STRING_REGEX: RegExp = /[\\x00-\\x1f\\x7f]+/\n","import { STRING } from '../utils/STRING.ts'\nimport { STRING_REGEX } from '../utils/STRING_REGEX.ts'\nimport type { ParsedValue } from './ParsedValue.ts'\nimport { parsedValue } from './ParsedValue.ts'\nimport { parseError } from './parseError.ts'\n\n// 4.2.5.  Parsing a String\n//\n// Given an ASCII string as input_string, return an unquoted String.\n// input_string is modified to remove the parsed value.\n//\n// 1.  Let output_string be an empty string.\n//\n// 2.  If the first character of input_string is not DQUOTE, fail\n//     parsing.\n//\n// 3.  Discard the first character of input_string.\n//\n// 4.  While input_string is not empty:\n//\n//     1.  Let char be the result of consuming the first character of\n//         input_string.\n//\n//     2.  If char is a backslash (\"\\\"):\n//\n//         1.  If input_string is now empty, fail parsing.\n//\n//         2.  Let next_char be the result of consuming the first\n//             character of input_string.\n//\n//         3.  If next_char is not DQUOTE or \"\\\", fail parsing.\n//\n//         4.  Append next_char to output_string.\n//\n//     3.  Else, if char is DQUOTE, return output_string.\n//\n//     4.  Else, if char is in the range %x00-1f or %x7f (i.e., is not\n//         in VCHAR or SP), fail parsing.\n//\n//     5.  Else, append char to output_string.\n//\n// 5.  Reached the end of input_string without finding a closing DQUOTE;\n//     fail parsing.\n/**\n * @internal\n */\nexport function parseString(src: string): ParsedValue<string> {\n\tlet output = ''\n\tlet i = 0\n\n\tif (src[i] !== `\"`) {\n\t\tthrow parseError(src, STRING)\n\t}\n\n\ti++\n\n\twhile (src.length > i) {\n\t\tif (src[i] === `\\\\`) {\n\t\t\tif (src.length <= i + 1) {\n\t\t\t\tthrow parseError(src, STRING)\n\t\t\t}\n\n\t\t\ti++\n\n\t\t\tif (src[i] !== `\"` && src[i] !== `\\\\`) {\n\t\t\t\tthrow parseError(src, STRING)\n\t\t\t}\n\n\t\t\toutput += src[i]\n\t\t}\n\t\telse if (src[i] === `\"`) {\n\t\t\treturn parsedValue(output, src.substring(++i))\n\t\t}\n\t\telse if (STRING_REGEX.test(src[i])) {\n\t\t\tthrow parseError(src, STRING)\n\t\t}\n\t\telse {\n\t\t\toutput += src[i]\n\t\t}\n\n\t\ti++\n\t}\n\n\tthrow parseError(src, STRING)\n}\n","/**\n * A class to represent structured field tokens when `Symbol` is not available.\n *\n *\n * @beta\n */\nexport class SfToken {\n\tdescription: string\n\n\tconstructor(description: string) {\n\t\tthis.description = description\n\t}\n}\n","export const TOKEN = 'Token'\n","import type { SfDecodeOptions } from '../SfDecodeOptions.ts'\nimport { SfToken } from '../SfToken.ts'\nimport { TOKEN } from '../utils/TOKEN.ts'\nimport type { ParsedValue } from './ParsedValue.ts'\nimport { parsedValue } from './ParsedValue.ts'\nimport { parseError } from './parseError.ts'\n\n// 4.2.6.  Parsing a Token\n//\n// Given an ASCII string as input_string, return a Token. input_string\n// is modified to remove the parsed value.\n//\n// 1.  If the first character of input_string is not ALPHA or \"*\", fail\n//     parsing.\n//\n// 2.  Let output_string be an empty string.\n//\n// 3.  While input_string is not empty:\n//\n//     1.  If the first character of input_string is not in tchar, \":\"\n//         or \"/\", return output_string.\n//\n//     2.  Let char be the result of consuming the first character of\n//         input_string.\n//\n//     3.  Append char to output_string.\n//\n// 4.  Return output_string.\n/**\n * @internal\n */\nexport function parseToken(src: string, options?: SfDecodeOptions): ParsedValue<symbol | SfToken> {\n\tif (/^[a-zA-Z*]$/.test(src[0]) === false) {\n\t\tthrow parseError(src, TOKEN)\n\t}\n\n\tconst re = /^([!#$%&'*+\\-.^_`|~\\w:/]+)/g\n\tconst value = (re.exec(src) as any)[1]\n\tsrc = src.substring(re.lastIndex)\n\n\treturn parsedValue(\n\t\toptions?.useSymbol === false ? new SfToken(value) : Symbol.for(value),\n\t\tsrc,\n\t)\n}\n","import type { SfBareItem } from '../SfBareItem.ts'\nimport type { SfDecodeOptions } from '../SfDecodeOptions.ts'\nimport { BARE_ITEM } from '../utils/BARE_ITEM.ts'\nimport type { ParsedValue } from './ParsedValue.ts'\nimport { parseBoolean } from './parseBoolean.ts'\nimport { parseByteSequence } from './parseByteSequence.ts'\nimport { parseDate } from './parseDate.ts'\nimport { parseError } from './parseError.ts'\nimport { parseIntegerOrDecimal } from './parseIntegerOrDecimal.ts'\nimport { parseString } from './parseString.ts'\nimport { parseToken } from './parseToken.ts'\n\n// 4.2.3.1.  Parsing a Bare Item\n//\n// Given an ASCII string as input_string, return a bare Item.\n// input_string is modified to remove the parsed value.\n//\n// 1.  If the first character of input_string is a \"-\" or a DIGIT,\n//     return the result of running Parsing an Integer or Decimal\n//     (Section 4.2.4) with input_string.\n//\n// 2.  If the first character of input_string is a DQUOTE, return the\n//     result of running Parsing a String (Section 4.2.5) with\n//     input_string.\n//\n// 3.  If the first character of input_string is \":\", return the result\n//     of running Parsing a Byte Sequence (Section 4.2.7) with\n//     input_string.\n//\n// 4.  If the first character of input_string is \"?\", return the result\n//     of running Parsing a Boolean (Section 4.2.8) with input_string.\n//\n// 5.  If the first character of input_string is an ALPHA or \"*\", return\n//     the result of running Parsing a Token (Section 4.2.6) with\n//     input_string.\n//\n// 6.  If the first character of input_string is \"@\", return the result\n//     of running Parsing a Date (Section 4.2.9) with input_string.\n//\n// 7.  Otherwise, the item type is unrecognized; fail parsing.\n/**\n * @internal\n */\nexport function parseBareItem(src: string, options?: SfDecodeOptions): ParsedValue<SfBareItem> {\n\tconst first = src[0]\n\tif (first === `\"`) {\n\t\treturn parseString(src)\n\t}\n\tif (/^[-0-9]/.test(first)) {\n\t\treturn parseIntegerOrDecimal(src)\n\t}\n\tif (first === `?`) {\n\t\treturn parseBoolean(src)\n\t}\n\tif (first === `:`) {\n\t\treturn parseByteSequence(src)\n\t}\n\tif (/^[a-zA-Z*]/.test(first)) {\n\t\treturn parseToken(src, options)\n\t}\n\tif (first === `@`) {\n\t\treturn parseDate(src)\n\t}\n\tthrow parseError(src, BARE_ITEM)\n}\n","export const KEY = 'Key'\n","import { KEY } from '../utils/KEY.ts'\nimport type { ParsedValue } from './ParsedValue.ts'\nimport { parsedValue } from './ParsedValue.ts'\nimport { parseError } from './parseError.ts'\n\n// 4.2.3.3.  Parsing a Key\n//\n// Given an ASCII string as input_string, return a key. input_string is\n// modified to remove the parsed value.\n//\n// 1.  If the first character of input_string is not lcalpha or \"*\",\n//     fail parsing.\n//\n// 2.  Let output_string be an empty string.\n//\n// 3.  While input_string is not empty:\n//\n//     1.  If the first character of input_string is not one of lcalpha,\n//         DIGIT, \"_\", \"-\", \".\", or \"*\", return output_string.\n//\n//     2.  Let char be the result of consuming the first character of\n//         input_string.\n//\n//     3.  Append char to output_string.\n//\n// 4.  Return output_string.\n/**\n * @internal\n */\nexport function parseKey(src: string): ParsedValue<string> {\n\tlet i = 0\n\tif (/^[a-z*]$/.test(src[i]) === false) {\n\t\tthrow parseError(src, KEY)\n\t}\n\n\tlet value = ''\n\n\twhile (src.length > i) {\n\t\tif (/^[a-z0-9_\\-.*]$/.test(src[i]) === false) {\n\t\t\treturn parsedValue(value, src.substring(i))\n\t\t}\n\n\t\tvalue += src[i]\n\t\ti++\n\t}\n\n\treturn parsedValue(value, src.substring(i))\n}\n","import type { SfDecodeOptions } from '../SfDecodeOptions.ts'\nimport type { SfParameters } from '../SfParameters.ts'\nimport type { ParsedValue } from './ParsedValue.ts'\nimport { parsedValue } from './ParsedValue.ts'\nimport { parseBareItem } from './parseBareItem.ts'\nimport { parseKey } from './parseKey.ts'\n\n// 4.2.3.2.  Parsing Parameters\n//\n// Given an ASCII string as input_string, return an ordered map whose\n// values are bare Items. input_string is modified to remove the parsed\n// value.\n//\n// 1.  Let parameters be an empty, ordered map.\n//\n// 2.  While input_string is not empty:\n//\n//     1.  If the first character of input_string is not \";\", exit the\n//         loop.\n//\n//     2.  Consume a \";\" character from the beginning of input_string.\n//\n//     3.  Discard any leading SP characters from input_string.\n//\n//     4.  let param_name be the result of running Parsing a Key\n//         (Section 4.2.3.3) with input_string.\n//\n//     5.  Let param_value be Boolean true.\n//\n//     6.  If the first character of input_string is \"=\":\n//\n//         1.  Consume the \"=\" character at the beginning of\n//             input_string.\n//\n//         2.  Let param_value be the result of running Parsing a Bare\n//             Item (Section 4.2.3.1) with input_string.\n//\n//     7.  Append key param_name with value param_value to parameters.\n//         If parameters already contains a name param_name (comparing\n//         character-for-character), overwrite its value.\n//\n// 3.  Return parameters.\n//\n// Note that when duplicate Parameter keys are encountered, this has the\n// effect of ignoring all but the last instance.\n/**\n * @internal\n */\nexport function parseParameters(src: string, options?: SfDecodeOptions): ParsedValue<SfParameters | undefined> {\n\tlet parameters: SfParameters | undefined = undefined\n\twhile (src.length > 0) {\n\t\tif (src[0] !== ';') {\n\t\t\tbreak\n\t\t}\n\n\t\tsrc = src.substring(1).trim()\n\t\tconst parsedKey = parseKey(src)\n\t\tconst key = parsedKey.value\n\t\tlet value = true\n\t\tsrc = parsedKey.src\n\n\t\tif (src[0] === '=') {\n\t\t\tsrc = src.substring(1)\n\t\t\tconst parsedBareItem = parseBareItem(src, options)\n\t\t\tvalue = parsedBareItem.value as any\n\t\t\tsrc = parsedBareItem.src\n\t\t}\n\n\t\t// initialize as object when params exists\n\t\tif (parameters == null) {\n\t\t\tparameters = {}\n\t\t}\n\n\t\t// override if param_name exists\n\t\tparameters[key] = value\n\t}\n\treturn parsedValue(parameters, src)\n}\n","import type { SfDecodeOptions } from '../SfDecodeOptions.ts'\nimport { SfItem } from '../SfItem.ts'\nimport type { ParsedValue } from './ParsedValue.ts'\nimport { parsedValue } from './ParsedValue.ts'\nimport { parseBareItem } from './parseBareItem.ts'\nimport { parseParameters } from './parseParameters.ts'\n\n// 4.2.3.  Parsing an Item\n//\n// Given an ASCII string as input_string, return a (bare_item,\n// parameters) tuple. input_string is modified to remove the parsed\n// value.\n//\n// 1.  Let bare_item be the result of running Parsing a Bare Item\n//     (Section 4.2.3.1) with input_string.\n//\n// 2.  Let parameters be the result of running Parsing Parameters\n//     (Section 4.2.3.2) with input_string.\n//\n// 3.  Return the tuple (bare_item, parameters).\n/**\n * @internal\n */\nexport function parseItem(src: string, options?: SfDecodeOptions): ParsedValue<SfItem> {\n\tconst parsedBareItem = parseBareItem(src, options)\n\tsrc = parsedBareItem.src\n\n\tconst parsedParameters = parseParameters(src, options)\n\tsrc = parsedParameters.src\n\n\treturn parsedValue(\n\t\tnew SfItem(parsedBareItem.value, parsedParameters.value),\n\t\tsrc,\n\t)\n}\n","import type { SfDecodeOptions } from '../SfDecodeOptions.ts'\nimport type { SfInnerList } from '../SfInnerList.ts'\nimport { SfItem } from '../SfItem.ts'\nimport { INNER } from '../utils/INNER.ts'\nimport type { ParsedValue } from './ParsedValue.ts'\nimport { parsedValue } from './ParsedValue.ts'\nimport { parseError } from './parseError.ts'\nimport { parseItem } from './parseItem.ts'\nimport { parseParameters } from './parseParameters.ts'\n\n// 4.2.1.2.  Parsing an Inner List\n//\n// Given an ASCII string as input_string, return the tuple (inner_list,\n// parameters), where inner_list is an array of (bare_item, parameters)\n// tuples. input_string is modified to remove the parsed value.\n//\n// 1.  Consume the first character of input_string; if it is not \"(\",\n//     fail parsing.\n//\n// 2.  Let inner_list be an empty array.\n//\n// 3.  While input_string is not empty:\n//\n//     1.  Discard any leading SP characters from input_string.\n//\n//     2.  If the first character of input_string is \")\":\n//\n//         1.  Consume the first character of input_string.\n//\n//         2.  Let parameters be the result of running Parsing\n//             Parameters (Section 4.2.3.2) with input_string.\n//\n//         3.  Return the tuple (inner_list, parameters).\n//\n//     3.  Let item be the result of running Parsing an Item\n//         (Section 4.2.3) with input_string.\n//\n//     4.  Append item to inner_list.\n//\n//     5.  If the first character of input_string is not SP or \")\", fail\n//         parsing.\n//\n// 4.  The end of the inner list was not found; fail parsing.\n/**\n * @internal\n */\nexport function parseInnerList(src: string, options?: SfDecodeOptions): ParsedValue<SfInnerList> {\n\tif (src[0] !== '(') {\n\t\tthrow parseError(src, INNER)\n\t}\n\n\tsrc = src.substring(1)\n\tconst innerList: SfItem[] = []\n\twhile (src.length > 0) {\n\t\tsrc = src.trim()\n\t\tif (src[0] === ')') {\n\t\t\tsrc = src.substring(1)\n\t\t\tconst parsedParameters = parseParameters(src, options)\n\n\t\t\treturn parsedValue(\n\t\t\t\tnew SfItem(innerList, parsedParameters.value) as any,\n\t\t\t\tparsedParameters.src,\n\t\t\t)\n\t\t}\n\n\t\tconst parsedItem = parseItem(src, options)\n\t\tinnerList.push(parsedItem.value)\n\t\tsrc = parsedItem.src\n\n\t\tif (src[0] !== ' ' && src[0] !== ')') {\n\t\t\tthrow parseError(src, INNER)\n\t\t}\n\t}\n\n\tthrow parseError(src, INNER)\n}\n","import type { SfDecodeOptions } from '../SfDecodeOptions.ts'\nimport type { SfInnerList } from '../SfInnerList.ts'\nimport type { SfItem } from '../SfItem.ts'\nimport type { ParsedValue } from './ParsedValue.ts'\nimport { parseInnerList } from './parseInnerList.ts'\nimport { parseItem } from './parseItem.ts'\n\n// 4.2.1.1.  Parsing an Item or Inner List\n//\n// Given an ASCII string as input_string, return the tuple\n// (item_or_inner_list, parameters), where item_or_inner_list can be\n// either a single bare item, or an array of (bare_item, parameters)\n// tuples. input_string is modified to remove the parsed value.\n//\n// 1.  If the first character of input_string is \"(\", return the result\n//     of running Parsing an Inner List (Section 4.2.1.2) with\n//     input_string.\n//\n// 2.  Return the result of running Parsing an Item (Section 4.2.3) with\n//     input_string.\n/**\n * @internal\n */\nexport function parseItemOrInnerList(src: string, options?: SfDecodeOptions): ParsedValue<SfItem | SfInnerList> {\n\tif (src[0] === '(') {\n\t\treturn parseInnerList(src, options)\n\t}\n\n\treturn parseItem(src, options)\n}\n","import type { SfDecodeOptions } from '../SfDecodeOptions.ts'\nimport type { SfDictionary } from '../SfDictionary.ts'\nimport type { SfInnerList } from '../SfInnerList.ts'\nimport { SfItem } from '../SfItem.ts'\nimport { DICT } from '../utils/DICT.ts'\nimport type { ParsedValue } from './ParsedValue.ts'\nimport { parsedValue } from './ParsedValue.ts'\nimport { parseError } from './parseError.ts'\nimport { parseItemOrInnerList } from './parseItemOrInnerList.ts'\nimport { parseKey } from './parseKey.ts'\nimport { parseParameters } from './parseParameters.ts'\n\n// 4.2.2.  Parsing a Dictionary\n//\n// Given an ASCII string as input_string, return an ordered map whose\n// values are (item_or_inner_list, parameters) tuples. input_string is\n// modified to remove the parsed value.\n//\n// 1.  Let dictionary be an empty, ordered map.\n//\n// 2.  While input_string is not empty:\n//\n//     1.  Let this_key be the result of running Parsing a Key\n//         (Section 4.2.3.3) with input_string.\n//\n//     2.  If the first character of input_string is \"=\":\n//\n//         1.  Consume the first character of input_string.\n//\n//         2.  Let member be the result of running Parsing an Item or\n//             Inner List (Section 4.2.1.1) with input_string.\n//\n//     3.  Otherwise:\n//\n//         1.  Let value be Boolean true.\n//\n//         2.  Let parameters be the result of running Parsing\n//             Parameters Section 4.2.3.2 with input_string.\n//\n//         3.  Let member be the tuple (value, parameters).\n//\n//     4.  Add name this_key with value member to dictionary.  If\n//         dictionary already contains a name this_key (comparing\n//         character-for-character), overwrite its value.\n//\n//     5.  Discard any leading OWS characters from input_string.\n//\n//     6.  If input_string is empty, return dictionary.\n//\n//     7.  Consume the first character of input_string; if it is not\n//         \",\", fail parsing.\n//\n//     8.  Discard any leading OWS characters from input_string.\n//\n//     9.  If input_string is empty, there is a trailing comma; fail\n//         parsing.\n//\n// 3.  No structured data has been found; return dictionary (which is\n//     empty).\n//\n// Note that when duplicate Dictionary keys are encountered, this has\n// the effect of ignoring all but the last instance.\n/**\n * @internal\n */\nexport function parseDict(src: string, options?: SfDecodeOptions): ParsedValue<SfDictionary> {\n\tconst value: SfDictionary = {}\n\n\twhile (src.length > 0) {\n\t\tlet member: SfItem | SfInnerList\n\t\tconst parsedKey = parseKey(src)\n\t\tconst key = parsedKey.value\n\t\tsrc = parsedKey.src\n\n\t\tif (src[0] === '=') {\n\t\t\tconst parsedItemOrInnerList = parseItemOrInnerList(src.substring(1), options)\n\t\t\tmember = parsedItemOrInnerList.value\n\t\t\tsrc = parsedItemOrInnerList.src\n\t\t}\n\t\telse {\n\t\t\tconst parsedParameters = parseParameters(src, options)\n\t\t\tmember = new SfItem(true, parsedParameters.value)\n\t\t\tsrc = parsedParameters.src\n\t\t}\n\n\t\tvalue[key] = member\n\n\t\tsrc = src.trim()\n\t\tif (src.length === 0) {\n\t\t\treturn parsedValue(value, src)\n\t\t}\n\n\t\tif (src[0] !== ',') {\n\t\t\tthrow parseError(src, DICT)\n\t\t}\n\n\t\tsrc = src.substring(1).trim()\n\t\tif (src.length === 0 || src[0] === ',') {\n\t\t\tthrow parseError(src, DICT)\n\t\t}\n\t}\n\n\treturn parsedValue(value, src)\n}\n","import type { SfDecodeOptions } from './SfDecodeOptions.ts'\nimport type { SfDictionary } from './SfDictionary.ts'\nimport { parseDict } from './parse/parseDict.ts'\nimport { parseError } from './parse/parseError.ts'\nimport { DICT } from './utils/DICT.ts'\n\n/**\n * Decode a structured field string into a structured field dictionary\n *\n * @param input - The structured field string to decode\n * @returns The structured field dictionary\n *\n *\n * @beta\n */\nexport function decodeSfDict(input: string, options?: SfDecodeOptions): SfDictionary {\n\ttry {\n\t\tconst { src, value } = parseDict(input.trim(), options)\n\t\tif (src !== '') {\n\t\t\tthrow parseError(src, DICT)\n\t\t}\n\t\treturn value\n\t}\n\tcatch (cause) {\n\t\tthrow parseError(input, DICT, cause)\n\t}\n}\n","export const ITEM = 'Item'\n","import type { SfDecodeOptions } from './SfDecodeOptions.ts'\nimport type { SfItem } from './SfItem.ts'\nimport { parseError } from './parse/parseError.ts'\nimport { parseItem } from './parse/parseItem.ts'\nimport { ITEM } from './utils/ITEM.ts'\n\n// 4.2.  Parsing Structured Fields\n//\n// 1.  Convert input_bytes into an ASCII string input_string; if\n//     conversion fails, fail parsing.\n//\n// 2.  Discard any leading SP characters from input_string.\n//\n// 3.  If field_type is \"list\", let output be the result of running\n//     Parsing a List (Section 4.2.1) with input_string.\n//\n// 4.  If field_type is \"dictionary\", let output be the result of\n//     running Parsing a Dictionary (Section 4.2.2) with input_string.\n//\n// 5.  If field_type is \"item\", let output be the result of running\n//     Parsing an Item (Section 4.2.3) with input_string.\n//\n// 6.  Discard any leading SP characters from input_string.\n//\n// 7.  If input_string is not empty, fail parsing.\n//\n// 8.  Otherwise, return output.\n/**\n * Decode a structured field string into a structured field item\n *\n * @param input - The structured field string to decode\n * @returns The structured field item\n *\n *\n * @beta\n */\nexport function decodeSfItem(input: string, options?: SfDecodeOptions): SfItem {\n\ttry {\n\t\tconst { src, value } = parseItem(input.trim(), options)\n\t\tif (src !== '') {\n\t\t\tthrow parseError(src, ITEM)\n\t\t}\n\n\t\treturn value\n\t}\n\tcatch (cause) {\n\t\tthrow parseError(input, ITEM, cause)\n\t}\n}\n","export const LIST = 'List'\n","import type { SfDecodeOptions } from '../SfDecodeOptions.ts'\nimport type { SfMember } from '../SfMember.ts'\nimport { LIST } from '../utils/LIST.ts'\nimport type { ParsedValue } from './ParsedValue.ts'\nimport { parsedValue } from './ParsedValue.ts'\nimport { parseError } from './parseError.ts'\nimport { parseItemOrInnerList } from './parseItemOrInnerList.ts'\n\n// 4.2.1.  Parsing a List\n//\n// Given an ASCII string as input_string, return an array of\n// (item_or_inner_list, parameters) tuples. input_string is modified to\n// remove the parsed value.\n//\n// 1.  Let members be an empty array.\n//\n// 2.  While input_string is not empty:\n//\n//     1.  Append the result of running Parsing an Item or Inner List\n//         (Section 4.2.1.1) with input_string to members.\n//\n//     2.  Discard any leading OWS characters from input_string.\n//\n//     3.  If input_string is empty, return members.\n//\n//     4.  Consume the first character of input_string; if it is not\n//         \",\", fail parsing.\n//\n//     5.  Discard any leading OWS characters from input_string.\n//\n//     6.  If input_string is empty, there is a trailing comma; fail\n//         parsing.\n//\n// 3.  No structured data has been found; return members (which is\n//     empty).\n/**\n * @internal\n */\nexport function parseList(src: string, options?: SfDecodeOptions): ParsedValue<SfMember[]> {\n\tconst value: SfMember[] = []\n\twhile (src.length > 0) {\n\t\tconst parsedItemOrInnerList = parseItemOrInnerList(src, options)\n\t\tvalue.push(parsedItemOrInnerList.value)\n\n\t\tsrc = parsedItemOrInnerList.src.trim()\n\t\tif (src.length === 0) {\n\t\t\treturn parsedValue(value, src)\n\t\t}\n\n\t\tif (src[0] !== ',') {\n\t\t\tthrow parseError(src, LIST)\n\t\t}\n\n\t\tsrc = src.substring(1).trim()\n\t\tif (src.length === 0 || src[0] === ',') {\n\t\t\tthrow parseError(src, LIST)\n\t\t}\n\t}\n\treturn parsedValue(value, src)\n}\n","import type { SfDecodeOptions } from './SfDecodeOptions.ts'\nimport type { SfMember } from './SfMember.ts'\nimport { parseError } from './parse/parseError.ts'\nimport { parseList } from './parse/parseList.ts'\nimport { LIST } from './utils/LIST.ts'\n\n/**\n * Decode a structured field string into a structured field list\n *\n * @param input - The structured field string to decode\n * @returns The structured field list\n *\n *\n * @beta\n */\nexport function decodeSfList(input: string, options?: SfDecodeOptions): SfMember[] {\n\ttry {\n\t\tconst { src, value } = parseList(input.trim(), options)\n\t\tif (src !== '') {\n\t\t\tthrow parseError(src, LIST)\n\t\t}\n\t\treturn value\n\t}\n\tcatch (cause) {\n\t\tthrow parseError(input, LIST, cause)\n\t}\n}\n","import { throwError } from '../utils/throwError.ts'\n\n/**\n * @internal\n */\nexport function serializeError(src: any, type: string, cause?: any): Error {\n\treturn throwError('serialize', src, type, cause)\n}\n","import { BOOLEAN } from '../utils/BOOLEAN.ts'\nimport { serializeError } from './serializeError.ts'\n\n// 4.1.9.  Serializing a Boolean\n//\n// Given a Boolean as input_boolean, return an ASCII string suitable for\n// use in a HTTP field value.\n//\n// 1.  If input_boolean is not a boolean, fail serialization.\n//\n// 2.  Let output be an empty string.\n//\n// 3.  Append \"?\" to output.\n//\n// 4.  If input_boolean is true, append \"1\" to output.\n//\n// 5.  If input_boolean is false, append \"0\" to output.\n//\n// 6.  Return output.\n/**\n * @internal\n */\nexport function serializeBoolean(value: boolean): string {\n\tif (typeof value !== 'boolean') {\n\t\tthrow serializeError(value, BOOLEAN)\n\t}\n\treturn value ? '?1' : '?0'\n}\n","import { encodeBase64 } from '@svta/cml-utils'\nimport { BYTES } from '../utils/BYTES.ts'\nimport { serializeError } from './serializeError.ts'\n\n// 4.1.8.  Serializing a Byte Sequence\n//\n// Given a Byte Sequence as input_bytes, return an ASCII string suitable\n// for use in a HTTP field value.\n//\n// 1.  If input_bytes is not a sequence of bytes, fail serialization.\n//\n// 2.  Let output be an empty string.\n//\n// 3.  Append \":\" to output.\n//\n// 4.  Append the result of base64-encoding input_bytes as per\n//     [RFC4648], Section 4, taking account of the requirements below.\n//\n// 5.  Append \":\" to output.\n//\n// 6.  Return output.\n//\n// The encoded data is required to be padded with \"=\", as per [RFC4648],\n// Section 3.2.\n//\n// Likewise, encoded data SHOULD have pad bits set to zero, as per\n// [RFC4648], Section 3.5, unless it is not possible to do so due to\n// implementation constraints.\n/**\n * @internal\n */\nexport function serializeByteSequence(value: Uint8Array) {\n\tif (ArrayBuffer.isView(value) === false) {\n\t\tthrow serializeError(value, BYTES)\n\t}\n\treturn `:${encodeBase64(value)}:`\n}\n","import { INTEGER } from '../utils/INTEGER.ts'\nimport { isInvalidInt } from '../utils/isInvalidInt.ts'\nimport { serializeError } from './serializeError.ts'\n\n// 4.1.4.  Serializing an Integer\n//\n// Given an Integer as input_integer, return an ASCII string suitable\n// for use in a HTTP field value.\n//\n// 1.  If input_integer is not an integer in the range of\n//     -999,999,999,999,999 to 999,999,999,999,999 inclusive, fail\n//     serialization.\n//\n// 2.  Let output be an empty string.\n//\n// 3.  If input_integer is less than (but not equal to) 0, append \"-\" to\n//     output.\n//\n// 4.  Append input_integer's numeric value represented in base 10 using\n//     only decimal digits to output.\n//\n// 5.  Return output.\n/**\n * @internal\n */\nexport function serializeInteger(value: number): string {\n\tif (isInvalidInt(value)) {\n\t\tthrow serializeError(value, INTEGER)\n\t}\n\n\treturn value.toString()\n}\n","import { serializeInteger } from './serializeInteger.ts'\n\n// 4.1.10.  Serializing a Date\n//\n// Given a Date as input_integer, return an ASCII string suitable for\n// use in an HTTP field value.\n// 1.  Let output be \"@\".\n// 2.  Append to output the result of running Serializing an Integer\n//     with input_date (Section 4.1.4).\n// 3.  Return output.\n/**\n * @internal\n */\nexport function serializeDate(value: Date) {\n\treturn `@${serializeInteger(value.getTime() / 1000)}`\n}\n","import { roundToEven } from '@svta/cml-utils'\nimport { DECIMAL } from '../utils/DECIMAL.ts'\nimport { serializeError } from './serializeError.ts'\n\n// 4.1.5.  Serializing a Decimal\n//\n// Given a decimal number as input_decimal, return an ASCII string\n// suitable for use in a HTTP field value.\n//\n// 1.   If input_decimal is not a decimal number, fail serialization.\n//\n// 2.   If input_decimal has more than three significant digits to the\n//      right of the decimal point, round it to three decimal places,\n//      rounding the final digit to the nearest value, or to the even\n//      value if it is equidistant.\n//\n// 3.   If input_decimal has more than 12 significant digits to the left\n//      of the decimal point after rounding, fail serialization.\n//\n// 4.   Let output be an empty string.\n//\n// 5.   If input_decimal is less than (but not equal to) 0, append \"-\"\n//      to output.\n//\n// 6.   Append input_decimal's integer component represented in base 10\n//      (using only decimal digits) to output; if it is zero, append\n//      \"0\".\n//\n// 7.   Append \".\" to output.\n//\n// 8.   If input_decimal's fractional component is zero, append \"0\" to\n//      output.\n//\n// 9.   Otherwise, append the significant digits of input_decimal's\n//      fractional component represented in base 10 (using only decimal\n//      digits) to output.\n//\n// 10.  Return output.\n/**\n * @internal\n */\nexport function serializeDecimal(value: number): string {\n\tconst roundedValue = roundToEven(value, 3) // round to 3 decimal places\n\tif (Math.floor(Math.abs(roundedValue)).toString().length > 12) {\n\t\tthrow serializeError(value, DECIMAL)\n\t}\n\tconst stringValue = roundedValue.toString()\n\treturn stringValue.includes('.') ? stringValue : `${stringValue}.0`\n}\n","import { STRING } from '../utils/STRING.ts'\nimport { STRING_REGEX } from '../utils/STRING_REGEX.ts'\nimport { serializeError } from './serializeError.ts'\n\n// 4.1.6.  Serializing a String\n//\n// Given a String as input_string, return an ASCII string suitable for\n// use in a HTTP field value.\n//\n// 1.  Convert input_string into a sequence of ASCII characters; if\n//     conversion fails, fail serialization.\n//\n// 2.  If input_string contains characters in the range %x00-1f or %x7f\n//     (i.e., not in VCHAR or SP), fail serialization.\n//\n// 3.  Let output be the string DQUOTE.\n//\n// 4.  For each character char in input_string:\n//\n//     1.  If char is \"\\\" or DQUOTE:\n//\n//         1.  Append \"\\\" to output.\n//\n//     2.  Append char to output.\n//\n// 5.  Append DQUOTE to output.\n//\n// 6.  Return output.\n/**\n * @internal\n */\nexport function serializeString(value: string) {\n\tif (STRING_REGEX.test(value)) {\n\t\tthrow serializeError(value, STRING)\n\t}\n\n\treturn `\"${value.replace(/\\\\/g, `\\\\\\\\`).replace(/\"/g, `\\\\\"`)}\"`\n}\n","import type { SfToken } from '../SfToken.ts'\n\n/**\n * Converts a symbol to a string.\n *\n * @param symbol - The symbol to convert.\n *\n * @returns The string representation of the symbol.\n *\n *\n * @beta\n */\nexport function symbolToStr(symbol: symbol | SfToken): string {\n\treturn symbol.description || symbol.toString().slice(7, -1)\n}\n","import type { SfToken } from '../SfToken.ts'\nimport { symbolToStr } from '../utils/symbolToStr.ts'\nimport { TOKEN } from '../utils/TOKEN.ts'\nimport { serializeError } from './serializeError.ts'\n\n// 4.1.7.  Serializing a Token\n//\n// Given a Token as input_token, return an ASCII string suitable for use\n// in a HTTP field value.\n//\n// 1.  Convert input_token into a sequence of ASCII characters; if\n//     conversion fails, fail serialization.\n//\n// 2.  If the first character of input_token is not ALPHA or \"*\", or the\n//     remaining portion contains a character not in tchar, \":\" or \"/\",\n//     fail serialization.\n//\n// 3.  Let output be an empty string.\n//\n// 4.  Append input_token to output.\n//\n// 5.  Return output.\n\n/**\n * @internal\n */\nexport function serializeToken(token: symbol | SfToken): string {\n\tconst value = symbolToStr(token)\n\tif (/^([a-zA-Z*])([!#$%&'*+\\-.^_`|~\\w:/]*)$/.test(value) === false) {\n\t\tthrow serializeError(value, TOKEN)\n\t}\n\treturn value\n}\n","import { SfToken } from '../SfToken.ts'\nimport { BARE_ITEM } from '../utils/BARE_ITEM.ts'\nimport { serializeBoolean } from './serializeBoolean.ts'\nimport { serializeByteSequence } from './serializeByteSequence.ts'\nimport { serializeDate } from './serializeDate.ts'\nimport { serializeDecimal } from './serializeDecimal.ts'\nimport { serializeError } from './serializeError.ts'\nimport { serializeInteger } from './serializeInteger.ts'\nimport { serializeString } from './serializeString.ts'\nimport { serializeToken } from './serializeToken.ts'\n\n// 4.1.3.1.  Serializing a Bare Item\n//\n// Given an Item as input_item, return an ASCII string suitable for use\n// in a HTTP field value.\n//\n// 1.  If input_item is an Integer, return the result of running\n//     Serializing an Integer (Section 4.1.4) with input_item.\n//\n// 2.  If input_item is a Decimal, return the result of running\n//     Serializing a Decimal (Section 4.1.5) with input_item.\n//\n// 3.  If input_item is a String, return the result of running\n//     Serializing a String (Section 4.1.6) with input_item.\n//\n// 4.  If input_item is a Token, return the result of running\n//     Serializing a Token (Section 4.1.7) with input_item.\n//\n// 5.  If input_item is a Boolean, return the result of running\n//     Serializing a Boolean (Section 4.1.9) with input_item.\n//\n// 6.  If input_item is a Byte Sequence, return the result of running\n//     Serializing a Byte Sequence (Section 4.1.8) with input_item.\n//\n// 7.  If input_item is a Date, return the result of running Serializing\n//     a Date (Section 4.1.10) with input_item.\n//\n// 8.  Otherwise, fail serialization.\n/**\n * @internal\n */\nexport function serializeBareItem(value: any): string {\n\tswitch (typeof value) {\n\t\tcase 'number':\n\t\t\tif (!Number.isFinite(value)) {\n\t\t\t\tthrow serializeError(value, BARE_ITEM)\n\t\t\t}\n\n\t\t\tif (Number.isInteger(value)) {\n\t\t\t\treturn serializeInteger(value)\n\t\t\t}\n\t\t\treturn serializeDecimal(value)\n\n\t\tcase 'string':\n\t\t\treturn serializeString(value)\n\n\t\tcase 'symbol':\n\t\t\treturn serializeToken(value)\n\n\t\tcase 'boolean':\n\t\t\treturn serializeBoolean(value)\n\n\t\tcase 'object':\n\t\t\tif (value instanceof Date) {\n\t\t\t\treturn serializeDate(value)\n\t\t\t}\n\t\t\tif (value instanceof Uint8Array) {\n\t\t\t\treturn serializeByteSequence(value)\n\t\t\t}\n\t\t\tif (value instanceof SfToken) {\n\t\t\t\treturn serializeToken(value)\n\t\t\t}\n\n\t\t// eslint-disable-next-line no-fallthrough\n\t\tdefault:\n\t\t\t// fail\n\t\t\tthrow serializeError(value, BARE_ITEM)\n\t}\n}\n","import { KEY } from '../utils/KEY.ts'\nimport { serializeError } from './serializeError.ts'\n\n// 4.1.1.3.  Serializing a Key\n//\n// Given a key as input_key, return an ASCII string suitable for use in\n// a HTTP field value.\n//\n// 1.  Convert input_key into a sequence of ASCII characters; if\n//     conversion fails, fail serialization.\n//\n// 2.  If input_key contains characters not in lcalpha, DIGIT, \"_\", \"-\",\n//     \".\", or \"*\" fail serialization.\n//\n// 3.  If the first character of input_key is not lcalpha or \"*\", fail\n//     serialization.\n//\n// 4.  Let output be an empty string.\n//\n// 5.  Append input_key to output.\n//\n// 6.  Return output.\n/**\n * @internal\n */\nexport function serializeKey(value: string): string {\n\tif (/^[a-z*][a-z0-9\\-_.*]*$/.test(value) === false) {\n\t\tthrow serializeError(value, KEY)\n\t}\n\treturn value\n}\n","import { serializeBareItem } from './serializeBareItem.ts'\nimport { serializeKey } from './serializeKey.ts'\n\n// 4.1.1.2.  Serializing Parameters\n//\n// Given an ordered Dictionary as input_parameters (each member having a\n// param_name and a param_value), return an ASCII string suitable for\n// use in a HTTP field value.\n//\n// 1.  Let output be an empty string.\n//\n// 2.  For each param_name with a value of param_value in\n//     input_parameters:\n//\n//     1.  Append \";\" to output.\n//\n//     2.  Append the result of running Serializing a Key\n//         (Section 4.1.1.3) with param_name to output.\n//\n//     3.  If param_value is not Boolean true:\n//\n//         1.  Append \"=\" to output.\n//\n//         2.  Append the result of running Serializing a bare Item\n//             (Section 4.1.3.1) with param_value to output.\n//\n// 3.  Return output.\n/**\n * @internal\n */\nexport function serializeParams(params?: Record<string, any>): string {\n\tif (params == null) {\n\t\treturn ''\n\t}\n\n\treturn Object.entries(params)\n\t\t.map(([key, value]) => {\n\t\t\tif (value === true) {\n\t\t\t\treturn `;${serializeKey(key)}` // omit true\n\t\t\t}\n\n\t\t\treturn `;${serializeKey(key)}=${serializeBareItem(value)}`\n\t\t})\n\t\t.join('')\n}\n","import type { SfBareItem } from '../SfBareItem.ts'\nimport { SfItem } from '../SfItem.ts'\nimport { serializeBareItem } from './serializeBareItem.ts'\nimport { serializeParams } from './serializeParams.ts'\n\n// 4.1.3.  Serializing an Item\n//\n// Given an Item as bare_item and Parameters as item_parameters, return\n// an ASCII string suitable for use in a HTTP field value.\n//\n// 1.  Let output be an empty string.\n//\n// 2.  Append the result of running Serializing a Bare Item\n//     Section 4.1.3.1 with bare_item to output.\n//\n// 3.  Append the result of running Serializing Parameters\n//     Section 4.1.1.2 with item_parameters to output.\n//\n// 4.  Return output.\n/**\n * @internal\n */\nexport function serializeItem(value: SfItem | SfBareItem): string {\n\tif (value instanceof SfItem) {\n\t\treturn `${serializeBareItem(value.value)}${serializeParams(value.params)}`\n\t}\n\telse {\n\t\treturn serializeBareItem(value)\n\t}\n}\n","import type { SfInnerList } from '../SfInnerList.ts'\nimport { serializeItem } from './serializeItem.ts'\nimport { serializeParams } from './serializeParams.ts'\n\n// 4.1.1.1.  Serializing an Inner List\n//\n// Given an array of (member_value, parameters) tuples as inner_list,\n// and parameters as list_parameters, return an ASCII string suitable\n// for use in a HTTP field value.\n//\n// 1.  Let output be the string \"(\".\n//\n// 2.  For each (member_value, parameters) of inner_list:\n//\n//     1.  Append the result of running Serializing an Item\n//         (Section 4.1.3) with (member_value, parameters) to output.\n//\n//     2.  If more values remain in inner_list, append a single SP to\n//         output.\n//\n// 3.  Append \")\" to output.\n//\n// 4.  Append the result of running Serializing Parameters\n//     (Section 4.1.1.2) with list_parameters to output.\n//\n// 5.  Return output.\n/**\n * @internal\n */\nexport function serializeInnerList(value: SfInnerList) {\n\treturn `(${value.value.map(serializeItem).join(' ')})${serializeParams(value.params)}`\n}\n","import type { SfEncodeOptions } from '../SfEncodeOptions.ts'\nimport { SfItem } from '../SfItem.ts'\nimport { DICT } from '../utils/DICT.ts'\nimport { serializeError } from './serializeError.ts'\nimport { serializeInnerList } from './serializeInnerList.ts'\nimport { serializeItem } from './serializeItem.ts'\nimport { serializeKey } from './serializeKey.ts'\nimport { serializeParams } from './serializeParams.ts'\n\n// 4.1.2.  Serializing a Dictionary\n//\n// Given an ordered Dictionary as input_dictionary (each member having a\n// member_name and a tuple value of (member_value, parameters)), return\n// an ASCII string suitable for use in a HTTP field value.\n//\n// 1.  Let output be an empty string.\n//\n// 2.  For each member_name with a value of (member_value, parameters)\n//     in input_dictionary:\n//\n//     1.  Append the result of running Serializing a Key\n//         (Section 4.1.1.3) with member's member_name to output.\n//\n//     2.  If member_value is Boolean true:\n//\n//         1.  Append the result of running Serializing Parameters\n//             (Section 4.1.1.2) with parameters to output.\n//\n//     3.  Otherwise:\n//\n//         1.  Append \"=\" to output.\n//\n//         2.  If member_value is an array, append the result of running\n//             Serializing an Inner List (Section 4.1.1.1) with\n//             (member_value, parameters) to output.\n//\n//         3.  Otherwise, append the result of running Serializing an\n//             Item (Section 4.1.3) with (member_value, parameters) to\n//             output.\n//\n//     4.  If more members remain in input_dictionary:\n//\n//         1.  Append \",\" to output.\n//\n//         2.  Append a single SP to output.\n//\n// 3.  Return output.\n/**\n * @internal\n */\nexport function serializeDict(dict: Record<string, any> | Map<string, any>, options: SfEncodeOptions = { whitespace: true }): string {\n\tif (typeof dict !== 'object' || dict == null) {\n\t\tthrow serializeError(dict, DICT)\n\t}\n\n\tconst entries = dict instanceof Map ? dict.entries() : Object.entries(dict)\n\tconst optionalWhiteSpace = options?.whitespace ? ' ' : ''\n\n\treturn Array.from(entries)\n\t\t.map(([key, item]) => {\n\t\t\tif (item instanceof SfItem === false) {\n\t\t\t\titem = new SfItem(item)\n\t\t\t}\n\t\t\tlet output = serializeKey(key)\n\t\t\tif (item.value === true) {\n\t\t\t\toutput += serializeParams(item.params)\n\t\t\t}\n\t\t\telse {\n\t\t\t\toutput += '='\n\t\t\t\tif (Array.isArray(item.value)) {\n\t\t\t\t\toutput += serializeInnerList(item)\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\toutput += serializeItem(item)\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn output\n\t\t})\n\t\t.join(`,${optionalWhiteSpace}`)\n}\n","import type { SfEncodeOptions } from './SfEncodeOptions.ts'\nimport { serializeDict } from './serialize/serializeDict.ts'\n\n/**\n * Encode an object into a structured field dictionary\n *\n * @param value - The structured field dictionary to encode\n * @param options - Encoding options\n *\n * @returns The structured field string\n *\n *\n * @beta\n */\nexport function encodeSfDict(value: Record<string, any> | Map<string, any>, options?: SfEncodeOptions): string {\n\treturn serializeDict(value, options)\n}\n","import type { SfBareItem } from './SfBareItem.ts'\nimport { SfItem } from './SfItem.ts'\nimport type { SfParameters } from './SfParameters.ts'\nimport { serializeItem } from './serialize/serializeItem.ts'\n\n/**\n * Encode a structured field item to a string\n *\n * @param value - The structured field item to encode\n *\n * @returns The structured field string\n *\n *\n * @beta\n */\nexport function encodeSfItem(value: SfItem): string;\n\n/**\n * Encode a structured field value to a string with optional parameters.\n *\n * @param value - The structured field value to encode\n * @param params - The structured field parameters\n *\n * @returns The structured field string\n *\n * @beta\n */\nexport function encodeSfItem(value: SfBareItem, params?: SfParameters): string;\n\nexport function encodeSfItem(value: SfItem | SfBareItem, params?: SfParameters) {\n\tif (!(value instanceof SfItem)) {\n\t\tvalue = new SfItem(value, params)\n\t}\n\n\treturn serializeItem(value)\n}\n","import type { SfEncodeOptions } from '../SfEncodeOptions.ts'\nimport { SfItem } from '../SfItem.ts'\nimport type { SfMember } from '../SfMember.ts'\nimport { LIST } from '../utils/LIST.ts'\nimport { serializeError } from './serializeError.ts'\nimport { serializeInnerList } from './serializeInnerList.ts'\nimport { serializeItem } from './serializeItem.ts'\n\n// 4.1.1.  Serializing a List\n//\n// Given an array of (member_value, parameters) tuples as input_list,\n// return an ASCII string suitable for use in a HTTP field value.\n//\n// 1.  Let output be an empty string.\n//\n// 2.  For each (member_value, parameters) of input_list:\n//\n//     1.  If member_value is an array, append the result of running\n//         Serializing an Inner List (Section 4.1.1.1) with\n//         (member_value, parameters) to output.\n//\n//     2.  Otherwise, append the result of running Serializing an Item\n//         (Section 4.1.3) with (member_value, parameters) to output.\n//\n//     3.  If more member_values remain in input_list:\n//\n//         1.  Append \",\" to output.\n//\n//         2.  Append a single SP to output.\n//\n// 3.  Return output.\n/**\n * @internal\n */\nexport function serializeList(list: SfMember[], options: SfEncodeOptions = { whitespace: true }): string {\n\tif (Array.isArray(list) === false) {\n\t\tthrow serializeError(list, LIST)\n\t}\n\n\tconst optionalWhiteSpace = options?.whitespace ? ' ' : ''\n\n\treturn list\n\t\t.map(item => {\n\t\t\tif (item instanceof SfItem === false) {\n\t\t\t\titem = new SfItem(item)\n\t\t\t}\n\n\t\t\t// TODO: Fix this type assertion\n\t\t\tconst i = item as any\n\t\t\tif (Array.isArray(i.value)) {\n\t\t\t\treturn serializeInnerList(i)\n\t\t\t}\n\n\t\t\treturn serializeItem(i)\n\t\t})\n\t\t.join(`,${optionalWhiteSpace}`)\n}\n","import type { SfEncodeOptions } from './SfEncodeOptions.ts'\nimport type { SfMember } from './SfMember.ts'\nimport { serializeList } from './serialize/serializeList.ts'\n\n/**\n * Encode a list into a structured field dictionary\n *\n * @param value - The structured field list to encode\n * @param options - Encoding options\n *\n * @returns The structured field string\n *\n *\n * @beta\n */\nexport function encodeSfList(value: SfMember[], options?: SfEncodeOptions): string {\n\treturn serializeList(value, options)\n}\n"],"mappings":"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"}